# Apropos architecture

Apropos is intended to provide a framework for easing specification as well as
comprehensive testing of Plutus contracts.

Apropos follows a layered approach. Specification and tests are developed layer
by layer, from the bottom to the top, with the results of each building on the
previous.

Tests are derived from specification, and the specification is developed
incrementally by [replacing validation with
parsing](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate).

## Adjoint functions

The framework is architected around a concept of adjoint functions - similar to
isomorphisms, but weaker.

```haskell
data Adjunction a b = Adjunction
  { left :: !(a -> b)
  , right :: !(b -> a)
  }
```

These must satisfy a law, `left . right === id`, although not neccesarily `right
. left === id`.

## Single-script layer

For each script, a developer defines a `TxTest`, and a pair of types, `bad` and
`good`.

```haskell
newtype TxTest bad good = TxTest (Adjunction (Either bad good) (Tx 'Unbalanced))
```

These types are intended to parse `Tx`s into types that capture valid and
invalid invocations of a script respectively. These types must capture enough
information to recreate the transaction, so merely defining the `right` leg of
the adjunction guides the developer to fully define the behaviour of each
script.

The adjunction is not an isomorphism, because the transaction may contain
components that are uninteresting to your script.

The `good` type captures the intended use of your script, and the `bad` type
captures all failure cases.

As a (partial) example, if your script requires a transaction to contain exactly
one input with a specific datum `X`, then your `good` type will contain a field
`xIn :: TxOutRef`, and your bad type a list type, `xIns :: [TxOutRef]`,
capturing zero, one or multiple such inputs. In all but the most trivial cases,
the `bad` type will cover good transctions as well, and will need to be
protected by a smart constructor.

Scripts that rely on other scripts can just include a spend of a script output
and need not set up any of the conditions necessary to pass validation for that
script - this creates the equivalent of a logical implication.

The developer then tries to build good generators for the `good` and `bad`
types. The model itself can be tested for consistency by testing that the
adjunction round-trips correctly. Then the script itself can be tested to ensure
that all `Tx`s generated from `Left bad` values fail validation, and those
generated from `Right good` values succeed. This is done using a new
single-script tester that tests against (not neccesarily complete or balanced)
transactions.

_The ideas above have been more fully developed than those below_

## Full transaction layer

When we have written and run these tests, we have hopefully built confidence
that transactions generated from `good` values will actually be safe in
practice. So we define sets of scripts that may be used together. Each
combination of scripts is associated with a product type of `good` values, and a
transaction is generated by `<>`-appending together the `Tx`-result of each.

These transactions are not guaranteed to succeed, though. A transaction for
script `A` may introduce a component which is forbidden by script `B`. So
another layer of adjunctions from `Either fullBad fullGood` to `Product '[forall
good. good]` is needed to capture these potential conflict cases (while ignoring
`bad` values for individual scripts, which are eliminated in the previous
layer), as well as tidy up the representation of these 'abstract transactions'.
Again, these can be round-trip tested for consistency, and then composed with
the lower adjunctions to test these full transactions against actual scripts,
using `plutus-simple-model`.

## State machine layer

`fullGood` types typically will form something like a sum type defining valid
uses of your scripts. These will serve as the transitioms of your state machine.

For state machine testing, the developer define an ADT that specifies in
abstract, the valid state of your machine. For example, an auction contract may
look like:

```haskell
data AuctionState 
  = Open { bids :: [(PubKeyHash, Integer)] }
  | Closed { winner :: PubKeyHash }
  | Claimed
```

The developer then specifies a `Transition` type:

```haskell
data Transition state = forall fullGood. Transition 
  { transitions :: state -> Maybe (Gen fullGood)
  , execute :: fullGood -> state -> state
  , tx :: fullGood -> Tx 'Balanced
  }
```

And a set of properties relating the state to a `plutus-simple-model` blockchain
state (`Mock`):

```haskell
:: state -> Mock -> Test ()
```

The generator is used to generate `fullGood`s. These are then used to advance
both the abstract state and the `plutus-simple-model` blockchain. at each step,
the full set of invariants captured by the properties is checked. These can even
attempt transactions against the blockchain - 'evil hand' tests.
